<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense - Boss & Laser Edition</title>
    <style>
        :root {
            --bg: #020617; --panel: #0f172a; --text: #38bdf8;
            --accent: #3b82f6; --danger: #ef4444; --money: #fbbf24;
            --success: #10b981; --laser: #f43f5e;
        }
        body {
            margin: 0; background-color: var(--bg); color: #f8fafc;
            font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center;
        }
        #ui-top {
            padding: 15px; font-size: 24px; display: flex; gap: 40px;
            background: var(--panel); width: 100%; justify-content: center; border-bottom: 2px solid #1e293b;
        }
        #game-area { position: relative; display: flex; padding: 20px; gap: 25px; }
        canvas { background-color: #064e3b; border: 2px solid #334155; border-radius: 8px; cursor: crosshair; }
        
        #side-panel {
            width: 320px; background: var(--panel); padding: 20px; border-radius: 12px;
            display: flex; flex-direction: column; gap: 8px; border: 1px solid #1e293b;
        }

        .tower-option {
            background: #1e293b; padding: 12px; border-radius: 8px; cursor: pointer;
            border: 1px solid #334155; transition: 0.2s;
        }
        .tower-option:hover { border-color: var(--accent); }
        .tower-option.selected { border-color: var(--text); background: #020617; }

        .price-tag { color: var(--money); font-weight: bold; float: right; }

        #upgrade-menu {
            margin-top: 5px; padding: 15px; background: #020617;
            border-radius: 8px; display: none; border: 1px solid var(--success);
        }
        .up-btn {
            width: 100%; padding: 8px; margin-top: 5px; cursor: pointer; border: none; 
            border-radius: 4px; font-weight: 700; background: var(--success); color: white;
        }
        .up-btn:disabled { background: #334155; opacity: 0.5; }
        
        .btn-main {
            width: 100%; padding: 12px; cursor: pointer; border: none; 
            color: white; font-weight: 800; border-radius: 8px; margin-top: 5px;
        }
        #boss-warning {
            color: var(--danger); font-weight: bold; text-align: center; display: none;
            animation: blink 1s infinite; margin-bottom: 10px;
        }
        @keyframes blink { 0% {opacity:1} 50% {opacity:0} 100% {opacity:1} }
    </style>
</head>
<body>

<div id="ui-top">
    <span>üí∞ <b id="money-display">500</b></span>
    <span>‚ù§Ô∏è <b id="lives-display">15</b></span>
    <span>üëæ B√∏lge: <b id="wave-display">0</b></span>
</div>

<div id="game-area">
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div id="side-panel">
        <div id="boss-warning">‚ö†Ô∏è BOSS-RUNDE KOMMER! ‚ö†Ô∏è</div>
        <h3 style="margin:0">Arsenal</h3>
        <div class="tower-option" onclick="selectTower('basic', 250)" id="tower-basic">
            <b>Standard</b> <span class="price-tag">250g</span>
        </div>
        <div class="tower-option" onclick="selectTower('sniper', 600)" id="tower-sniper">
            <b>Sniper</b> <span class="price-tag">600g</span>
        </div>
        <div class="tower-option" onclick="selectTower('bomb', 500)" id="tower-bomb">
            <b>Artilleri</b> <span class="price-tag">500g</span>
        </div>
        <div class="tower-option" onclick="selectTower('frost', 400)" id="tower-frost">
            <b>Frost</b> <span class="price-tag">400g</span>
        </div>
        <div class="tower-option" onclick="selectTower('laser', 1000)" id="tower-laser">
            <b>Laser (Boss Killer)</b> <span class="price-tag">1000g</span>
        </div>

        <div id="upgrade-menu">
            <h4 id="up-title" style="margin:0; color:var(--text)">Oppgrader</h4>
            <button id="btn-dmg" class="up-btn" onclick="applyUpgrade('damage')">Skade (<span id="cost-dmg">400</span>g)</button>
            <button id="btn-spd" class="up-btn" onclick="applyUpgrade('speed')">Fart (<span id="cost-spd">400</span>g)</button>
            <button id="btn-rng" class="up-btn" onclick="applyUpgrade('range')">Rekkevidde (<span id="cost-rng">400</span>g)</button>
        </div>

        <button onclick="nextWave()" class="btn-main" style="background:#10b981; margin-top:20px;">NESTE B√òLGE</button>
        <button id="speed-btn" class="btn-main" style="background:#f59e0b;" onclick="toggleSpeed()">HASTIGHET: 1x</button>
        <button id="auto-btn" class="btn-main" style="background:#6366f1;" onclick="toggleAuto()">AUTO-START: AV</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 40;
    
    let money = 500;
    let lives = 15;
    let wave = 0;
    let autoStart = false;
    let gameSpeed = 1;
    let selectedTowerType = null;
    let selectedTowerCost = 0;
    let activeTower = null;
    
    let towers = [];
    let enemies = [];
    let bullets = [];
    let explosions = [];
    let waypoints = [{x:0,y:100}, {x:520,y:100}, {x:520,y:300}, {x:120,y:300}, {x:120,y:500}, {x:800,y:500}];
    let gameActive = true;

    const baseStats = {
        'basic': { name: "Standard", range: 140, fireRate: 30, color: '#38bdf8', damage: 40, type: 'attack' },
        'sniper': { name: "Sniper", range: 350, fireRate: 120, color: '#facc15', damage: 250, type: 'attack' },
        'bomb': { name: "Artilleri", range: 150, fireRate: 80, color: '#f87171', damage: 100, type: 'aoe', aoeRadius: 70 },
        'frost': { name: "Frost", range: 120, fireRate: 40, color: '#60a5fa', damage: 2, type: 'frost' },
        'laser': { name: "Laser", range: 180, fireRate: 5, color: '#f43f5e', damage: 10, type: 'laser' }
    };

    function selectTower(type, cost) {
        selectedTowerType = type;
        selectedTowerCost = cost;
        activeTower = null;
        document.getElementById('upgrade-menu').style.display = 'none';
        document.querySelectorAll('.tower-option').forEach(el => el.classList.remove('selected'));
        document.getElementById('tower-' + type).classList.add('selected');
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const rawX = e.clientX - rect.left;
        const rawY = e.clientY - rect.top;
        const gridX = Math.floor(rawX / gridSize) * gridSize + gridSize/2;
        const gridY = Math.floor(rawY / gridSize) * gridSize + gridSize/2;

        const clickedTower = towers.find(t => t.x === gridX && t.y === gridY);
        if (clickedTower) {
            activeTower = clickedTower;
            showUpgradeMenu();
        } else if (selectedTowerType && money >= selectedTowerCost) {
            if (isOverPath(gridX, gridY)) return;
            towers.push({
                x: gridX, y: gridY, ...JSON.parse(JSON.stringify(baseStats[selectedTowerType])),
                upgrades: { damage: 0, speed: 0, range: 0 }, timer: 0
            });
            money -= selectedTowerCost;
            updateUI();
        }
    });

    function isOverPath(x, y) {
        for(let i=0; i < waypoints.length-1; i++) {
            const p1 = waypoints[i]; const p2 = waypoints[i+1];
            const buffer = 35;
            if (x > Math.min(p1.x, p2.x)-buffer && x < Math.max(p1.x, p2.x)+buffer &&
                y > Math.min(p1.y, p2.y)-buffer && y < Math.max(p1.y, p2.y)+buffer) return true;
        }
        return false;
    }

    function showUpgradeMenu() {
        document.getElementById('upgrade-menu').style.display = 'block';
        document.getElementById('up-title').innerText = activeTower.name;
        updateUpgradeButtons();
    }

    function updateUpgradeButtons() {
        ['dmg', 'spd', 'rng'].forEach(p => {
            const fullPath = p === 'dmg' ? 'damage' : p === 'spd' ? 'speed' : 'range';
            const cost = 400 * Math.pow(2.2, activeTower.upgrades[fullPath]);
            document.getElementById('cost-' + p).innerText = Math.floor(cost);
            document.getElementById('btn-' + p).disabled = money < cost || activeTower.upgrades[fullPath] >= 6;
        });
    }

    function applyUpgrade(path) {
        const cost = 400 * Math.pow(2.2, activeTower.upgrades[path]);
        if (money >= cost) {
            money -= cost;
            activeTower.upgrades[path]++;
            if (path === 'damage') activeTower.damage *= 1.6;
            if (path === 'speed') activeTower.fireRate *= 0.8;
            if (path === 'range') activeTower.range += 40;
            updateUpgradeButtons();
            updateUI();
        }
    }

    function nextWave() {
        if (enemies.length > 0) return;
        wave++;
        updateUI();
        
        const isBossWave = wave % 10 === 0;
        document.getElementById('boss-warning').style.display = (wave % 10 === 9) ? 'block' : 'none';

        if (isBossWave) {
            enemies.push({
                x: waypoints[0].x, y: waypoints[0].y,
                health: 2000 * Math.pow(1.5, (wave/10)), speed: 0.5, color: '#ffffff',
                maxHealth: 2000 * Math.pow(1.5, (wave/10)), targetIdx: 1, type: 'boss', size: 30
            });
        } else {
            const count = 8 + (wave * 2);
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    let type = "standard";
                    if (i % 6 === 0 && wave > 3) type = "tank";
                    if (i % 4 === 0 && wave > 2) type = "scout";

                    const stats = {
                        standard: { health: 100 + (wave * 60), speed: 1.4, color: '#f43f5e', size: 14 },
                        tank: { health: 400 + (wave * 200), speed: 0.7, color: '#a855f7', size: 18 },
                        scout: { health: 50 + (wave * 30), speed: 2.8, color: '#fbbf24', size: 10 }
                    }[type];

                    enemies.push({
                        x: waypoints[0].x, y: waypoints[0].y, ...stats,
                        maxHealth: stats.health, targetIdx: 1, slowTimer: 0, type: type
                    });
                }, (i * 400) / gameSpeed);
            }
        }
    }

    function toggleSpeed() { gameSpeed = gameSpeed === 1 ? 2 : 1; document.getElementById('speed-btn').innerText = "HASTIGHET: " + gameSpeed + "x"; }
    function toggleAuto() { autoStart = !autoStart; document.getElementById('auto-btn').innerText = "AUTO-START: " + (autoStart ? "P√Ö" : "AV"); }

    function updateUI() {
        document.getElementById('money-display').innerText = Math.floor(money);
        document.getElementById('lives-display').innerText = lives;
        document.getElementById('wave-display').innerText = wave;
    }

    function updateLogic() {
        enemies.forEach((enemy, index) => {
            const target = waypoints[enemy.targetIdx];
            const dist = Math.hypot(target.x - enemy.x, target.y - enemy.y);
            let s = enemy.slowTimer > 0 ? enemy.speed * 0.5 : enemy.speed;
            if (enemy.slowTimer > 0) enemy.slowTimer--;

            if (dist < 5) {
                enemy.targetIdx++;
                if (enemy.targetIdx >= waypoints.length) {
                    lives -= (enemy.type === 'boss' ? 5 : 1);
                    enemies.splice(index, 1); updateUI(); return;
                }
            }
            enemy.x += ((target.x - enemy.x) / dist) * s;
            enemy.y += ((target.y - enemy.y) / dist) * s;
        });

        towers.forEach(t => {
            t.timer++;
            if (t.timer >= t.fireRate) {
                // Laser prioriterer fienden med mest helse innen rekkevidde
                const inRange = enemies.filter(e => Math.hypot(e.x - t.x, e.y - t.y) < t.range);
                const target = t.type === 'laser' ? inRange.sort((a,b) => b.health - a.health)[0] : inRange[0];
                
                if (target) {
                    if (t.type === 'laser') {
                        target.health -= t.damage;
                        ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.moveTo(t.x, t.y); ctx.lineTo(target.x, target.y); ctx.stroke();
                    } else {
                        bullets.push({x: t.x, y: t.y, target, damage: t.damage, type: t.type, aoeRadius: t.aoeRadius, color: t.color});
                    }
                    t.timer = 0;
                }
            }
        });

        bullets.forEach((b, i) => {
            const dist = Math.hypot(b.target.x - b.x, b.target.y - b.y);
            if (dist < 10 || !enemies.includes(b.target)) {
                if (enemies.includes(b.target)) {
                    if (b.type === 'frost') b.target.slowTimer = 50;
                    if (b.type === 'aoe') {
                        explosions.push({x: b.target.x, y: b.target.y, radius: b.aoeRadius, timer: 0});
                        enemies.forEach(e => { if (Math.hypot(e.x - b.target.x, e.y - b.target.y) < b.aoeRadius) e.health -= b.damage; });
                    } else b.target.health -= b.damage;
                    
                    enemies = enemies.filter(e => {
                        if (e.health <= 0) { money += (e.type === 'boss' ? 500 : 15); return false; }
                        return true;
                    });
                    updateUI();
                }
                bullets.splice(i, 1); return;
            }
            b.x += ((b.target.x - b.x) / dist) * 15;
            b.y += ((b.target.y - b.y) / dist) * 15;
        });

        explosions.forEach((exp, i) => { exp.timer++; if (exp.timer >= 15) explosions.splice(i, 1); });
        if (autoStart && enemies.length === 0) nextWave();
        if (lives <= 0) { alert("Base √∏delagt! B√∏lge: " + wave); location.reload(); }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Grid
        ctx.strokeStyle = "rgba(255,255,255,0.03)";
        for(let x=0; x<canvas.width; x+=gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
        for(let y=0; y<canvas.height; y+=gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

        // Bane
        ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 45; ctx.lineJoin = "round";
        ctx.beginPath(); ctx.moveTo(waypoints[0].x, waypoints[0].y);
        waypoints.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();

        // Fiender
        enemies.forEach(e => {
            ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill();
            if(e.type === 'boss') { ctx.strokeStyle = 'gold'; ctx.lineWidth = 2; ctx.stroke(); }
            ctx.fillStyle = '#10b981'; ctx.fillRect(e.x-15, e.y-e.size-10, (e.health/e.maxHealth)*30, 5);
        });

        // T√•rn
        towers.forEach(t => {
            ctx.fillStyle = t.color; ctx.fillRect(t.x-15, t.y-15, 30, 30);
            if (activeTower === t) {
                ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI*2); ctx.stroke();
            }
        });

        bullets.forEach(b => { ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI*2); ctx.fill(); });
        explosions.forEach(exp => {
            ctx.fillStyle = `rgba(248, 113, 113, ${1 - exp.timer/15})`;
            ctx.beginPath(); ctx.arc(exp.x, exp.y, exp.radius * (exp.timer/15), 0, Math.PI*2); ctx.fill();
        });
    }

    function gameLoop() {
        for (let s = 0; s < gameSpeed; s++) updateLogic();
        render();
        requestAnimationFrame(gameLoop);
    }

    updateUI();
    gameLoop();
</script>
</body>
</html>
