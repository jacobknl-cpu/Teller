<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <title>TD: Projectile & Ricochet Edition</title>
    <style>
        :root {
            --bg: #020617; --panel: #0f172a; --text: #38bdf8;
            --accent: #3b82f6; --danger: #ef4444; --money: #fbbf24;
            --success: #10b981; --special: #c084fc;
        }
        body { margin: 0; background: var(--bg); color: #f8fafc; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; }
        #ui-top { padding: 15px; font-size: 20px; display: flex; gap: 30px; background: var(--panel); width: 100%; justify-content: center; border-bottom: 2px solid #1e293b; }
        #game-area { display: flex; padding: 20px; gap: 20px; }
        canvas { background: #064e3b; border: 2px solid #334155; border-radius: 8px; }
        #side-panel { width: 380px; background: var(--panel); padding: 20px; border-radius: 12px; display: flex; flex-direction: column; gap: 10px; height: 90vh; overflow-y: auto; }
        .tower-option { background: #1e293b; padding: 10px; border-radius: 8px; cursor: pointer; border: 1px solid #334155; text-align: center; }
        .tower-option.selected { border-color: var(--text); background: #020617; }
        #upgrade-menu { padding: 15px; background: #020617; border-radius: 8px; display: none; border: 1px solid var(--accent); }
        .path-container { margin-bottom: 15px; padding: 10px; background: #1e293b; border-radius: 6px; }
        .path-power { font-size: 12px; color: var(--special); font-weight: bold; margin-bottom: 5px; }
        .up-btn { width: 100%; padding: 8px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; color: white; background: var(--success); }
        .up-btn:disabled { opacity: 0.3; background: #475569; }
        .btn-main { padding: 15px; cursor: pointer; border: none; color: white; font-weight: 800; border-radius: 8px; background: var(--success); }
    </style>
</head>
<body>

<div id="ui-top">
    <span>üí∞ <b id="money-display">1200</b></span>
    <span>üëæ B√∏lge: <b id="wave-display">0</b></span>
    <span>‚ù§Ô∏è Liv: <b id="lives-display">20</b></span>
</div>

<div id="game-area">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="side-panel">
        <h3 style="margin:0">Butikk</h3>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 5px;">
            <div class="tower-option" onclick="selectTower('basic', 200)" id="tower-basic">Standard</div>
            <div class="tower-option" onclick="selectTower('sniper', 500)" id="tower-sniper">Sniper</div>
        </div>
        <div id="upgrade-menu">
            <h4 id="up-title" style="margin:0 0 10px 0">Oppgrader</h4>
            <div id="paths-list"></div>
        </div>
        <button onclick="nextWave()" class="btn-main">START B√òLGE</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 40;
    let money = 1200, lives = 20, wave = 0, gameSpeed = 1;
    let towers = [], enemies = [], projectiles = [], activeTower = null, selectedTowerType = null, selectedTowerCost = 0;
    const waypoints = [{x:0,y:100}, {x:520,y:100}, {x:520,y:300}, {x:120,y:300}, {x:120,y:500}, {x:800,y:500}];

    const towerData = {
        'basic': {
            paths: [
                { name: "Fart", power: "MINIGUN: Utrolig hastighet", trait: "fireRate", mod: 0.75 },
                { name: "Styrke", power: "HEAVY: Dobbel skade", trait: "damage", mod: 1.4 },
                { name: "Sprett", power: "RICOCHET: Skudd spretter mellom fiender", trait: "range", mod: 1.1 }
            ],
            base: { range: 160, fireRate: 30, damage: 25, color: '#38bdf8' }
        },
        'sniper': {
            paths: [
                { name: "Kaliber", power: "PIERCE: G√•r gjennom 3 fiender", trait: "damage", mod: 1.6 },
                { name: "Sikte", power: "EAGLE: Ekstrem rekkevidde", trait: "range", mod: 1.5 },
                { name: "Lading", power: "QUICK: Raskere omlading", trait: "fireRate", mod: 0.8 }
            ],
            base: { range: 400, fireRate: 100, damage: 150, color: '#facc15' }
        }
    };

    function selectTower(type, cost) {
        selectedTowerType = type; selectedTowerCost = cost;
        document.querySelectorAll('.tower-option').forEach(e => e.classList.remove('selected'));
        document.getElementById('tower-'+type).classList.add('selected');
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / gridSize) * gridSize + gridSize/2;
        const y = Math.floor((e.clientY - rect.top) / gridSize) * gridSize + gridSize/2;
        const existing = towers.find(t => t.x === x && t.y === y);
        if (existing) { activeTower = existing; updateUpgradeMenu(); }
        else if (selectedTowerType && money >= selectedTowerCost) {
            towers.push({ x, y, type: selectedTowerType, levels: [0,0,0], timer: 0, ...JSON.parse(JSON.stringify(towerData[selectedTowerType].base)) });
            money -= selectedTowerCost; updateUI();
        }
    });

    function updateUpgradeMenu() {
        const menu = document.getElementById('upgrade-menu');
        const list = document.getElementById('paths-list');
        menu.style.display = 'block';
        list.innerHTML = '';
        towerData[activeTower.type].paths.forEach((p, i) => {
            const lv = activeTower.levels[i];
            const cost = (lv + 1) * 250;
            const container = document.createElement('div');
            container.className = 'path-container';
            container.innerHTML = `
                <div style="font-size:13px"><b>${p.name}</b> (Lv ${lv}/5)</div>
                <div class="path-power">${lv === 5 ? "AKTIVERT!" : "Lv 5: " + p.power}</div>
                <button class="up-btn" onclick="upgradePath(${i}, ${cost})" ${lv >= 5 || money < cost ? 'disabled' : ''}>${lv >= 5 ? 'MAX' : 'Oppgrader ('+cost+'g)'}</button>
            `;
            list.appendChild(container);
        });
    }

    function upgradePath(idx, cost) {
        if (money >= cost) {
            money -= cost; activeTower.levels[idx]++;
            const trait = towerData[activeTower.type].paths[idx].trait;
            activeTower[trait] *= towerData[activeTower.type].paths[idx].mod;
            updateUI(); updateUpgradeMenu();
        }
    }

    function spawnProjectile(tower, target, bounceCount = 0) {
        projectiles.push({
            x: tower.x, y: tower.y, target: target, speed: 7, 
            damage: tower.damage, color: tower.color,
            ricochet: (tower.type === 'basic' && tower.levels[2] === 5) ? 2 : bounceCount,
            originalTower: tower
        });
    }

    function nextWave() {
        if (enemies.length > 0) return;
        wave++; updateUI();
        for (let i = 0; i < 8 + wave*2; i++) {
            setTimeout(() => {
                enemies.push({ x: 0, y: 100, health: 50 + wave*40, maxH: 50 + wave*40, speed: 1.2, targetIdx: 1 });
            }, i * 500);
        }
    }

    function updateUI() { 
        document.getElementById('money-display').innerText = Math.floor(money); 
        document.getElementById('wave-display').innerText = wave;
        document.getElementById('lives-display').innerText = lives;
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Bane og Grid
        ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 35; ctx.lineJoin = "round";
        ctx.beginPath(); ctx.moveTo(0, 100); waypoints.forEach(p => ctx.lineTo(p.x, p.y)); ctx.stroke();

        // Fiender
        enemies.forEach((e, i) => {
            const target = waypoints[e.targetIdx];
            const dist = Math.hypot(target.x - e.x, target.y - e.y);
            if (dist < 5) { e.targetIdx++; if (e.targetIdx >= waypoints.length) { lives--; enemies.splice(i, 1); updateUI(); return; } }
            e.x += ((target.x - e.x) / dist) * e.speed;
            e.y += ((target.y - e.y) / dist) * e.speed;
            ctx.fillStyle = '#f43f5e'; ctx.beginPath(); ctx.arc(e.x, e.y, 10, 0, Math.PI*2); ctx.fill();
        });

        // T√•rn
        towers.forEach(t => {
            t.timer++;
            if (t.timer >= t.fireRate) {
                const target = enemies.find(e => Math.hypot(e.x - t.x, e.y - t.y) < t.range);
                if (target) { spawnProjectile(t, target); t.timer = 0; }
            }
            ctx.fillStyle = t.color; ctx.fillRect(t.x-15, t.y-15, 30, 30);
        });

        // Prosjektiler (Skudd)
        projectiles.forEach((p, pi) => {
            const dist = Math.hypot(p.target.x - p.x, p.target.y - p.y);
            if (dist < 8) {
                p.target.health -= p.damage;
                // RICOCHET LOGIKK
                if (p.ricochet > 0) {
                    const nextTarget = enemies.find(e => e !== p.target && Math.hypot(e.x - p.x, e.y - p.y) < 150);
                    if (nextTarget) {
                        p.x = p.target.x; p.y = p.target.y;
                        p.target = nextTarget; p.ricochet--;
                        return; // Fortsett til neste m√•l
                    }
                }
                projectiles.splice(pi, 1);
            } else {
                p.x += ((p.target.x - p.x) / dist) * p.speed;
                p.y += ((p.target.y - p.y) / dist) * p.speed;
                ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
            }
        });

        enemies = enemies.filter(e => { if(e.health <= 0) money += 15; return e.health > 0; });
        if (lives <= 0) { alert("Game Over!"); location.reload(); }
        requestAnimationFrame(gameLoop);
    }
    updateUI();
    gameLoop();
</script>
</body>
</html>
